<html>
	<head>
		<meta charset="UTF-8">

		<style>
			br
			{
				line-height: 340%;
			}

			div
			{
				line-height: 170%;
			}

			a
			{
				color: #C62818;
				text-decoration: none;
			}

			center
			{
				color: #C62818;
			}

			span
			{
				white-space: pre;
			}
		</style>

		<script type="text/javascript" src="/js/jquery.min.js"></script>
	</head>

	<body>
		<div style="font-family: CSChatThai; font-size: 28px; line-height: 150%; color: #C62818; float: left;"><b>Dynamic Programming - Intro</b>&#09;<font face="CSChatThai" size="4" color="#999999">-&#09;26.05.2016</font></div>
			
		<div style="font-family: CSChatThai; font-size: 18px; line-height: 170%; text-align: justify; color: #000000; clear: both;">
		ลองนึกภาพว่าคุณเป็นเด็กประถมคนหนึ่ง คุณกำลังเดินเข้ามาในห้อง นั่งลงบนเก้าอี้ตัวเอง แล้วก็เห็นคุณครูเขียนคำถามนี้บนกระดาน<br><center style="color: #000000;">4 + 2 + 1 + 3 + 7 + 7 + 1 + 2 = ?</center><br style="line-height: 240%;">คุณใช้เวลานับซักพัก แล้วก็ตอบไปว่าคำตอบคือ 27 ต่อจากนั้นคุณครูก็เขียนเลข 3 เพิ่มเข้าไปทางซ้ายอีกตัวหนึ่ง กลายเป็น<br><center style="color: #000000;">3 + 4 + 2 + 1 + 3 + 7 + 7 + 1 + 2 = ?</center><br style="line-height: 240%;">คราวนี้คุณตอบได้อย่างรวดเร็วว่าคำตอบคือ 30 ถ้าถามว่าทำไมคุณถึงตอบได้เร็ว คุณก็คงบอกว่าคุณจำคำตอบเดิมได้ แล้วก็แค่บวกสามเพิ่มมาอีกตัวก็จะได้คำตอบ การจำคำตอบของปัญหาที่เคยแก้แล้วเนี่ยแหละ ที่เป็นหัวใจของ Dynamic Programming<br>ไอเดียของ Dynamic Programming ก็คือการแบ่งปัญหาที่เราต้องการแก้ออกเป็นปัญหาเล็กๆ ที่สามารถแก้ได้ง่าย แล้วค่อยๆ ใช้สิ่งที่เราคิดไปแล้วมาช่วยใช้แก้ปัญหาที่ใหญ่ขึ้น จนเราได้คำตอบของปัญหาตอนแรก ถ้าอธิบายแบบนี้อาจจะยังนึกภาพไม่ออก เรามาลองดูปัญหาซักข้อหนึ่งกันดีกว่า<br>สมมติว่ามีต้นกล้วยเรียงอยู่แถวหนึ่ง ต้นกล้วยแต่ละต้นก็มีจำนวนกล้วยอยู่ไม่เท่ากัน ทีนี้ก้านกล้วย ซึ่งผ่านมาเห็นพอดี อยากจะวิ่งผ่านต้นกล้วยแถวนี้แล้วกระโดดกินกล้วยให้ได้หลายลูกที่สุด แต่น่าเสียดายเมื่อก้านกล้วยกระโดดกินกล้วยจากต้นกล้วยต้นหนึ่งแล้ว ก้านกล้วยจะตกลงมาที่พื้นและต้องวิ่งต่อซักพัก จึงสามารถกระโดดใหม่ได้ ดังนั้นก้านกล้วยจึงไม่สามารถกินกล้วยจากต้นกล้วยสองต้นที่อยู่ติดกันได้ สิ่งที่เราต้องหาคือ ถ้าก้านกล้วยวางแผนการกินดีที่สุดแล้ว จะกินกล้วยได้กี่ลูก (คิดว่าน่าจะเป็นโจทย์จากค่าย สสวท คอมพิวเตอร์ ค่ายแรก)<br><center><img src="html/articles/img/1b85b184_1.png"  width="80%"><br style="line-height:170%">ตัวอย่างสถานการณ์แบบหนึ่งในโจทย์ข้อนี้ ก้านกล้วยจะวิ่งจากซ้ายไปขวา ตัวเลขบนต้นไม้บอกว่ามีกล้วยกี่ลูกอยู่ในต้นกล้วยต้นนั้น<br></center>ในโจทย์ข้อนี้ เราจะลองใช้เทคนิค Dynamic Programming เพื่อแก้ดู เราจะลองบีบปัญหาให้เล็กลง เราเริ่มลองมองว่า ถ้ามีต้นกล้วยแค่ต้นแรกต้นเดียวแล้วควรจะทำยังไง แน่นอนว่าคำตอบในกรณีนั้นก็คือกินกล้วยจากต้นกล้วยต้นเดียวนั่นแหละ ถ้าลองขยายขึ้นให้มีต้นกล้วยสองต้นแรก เราก็เลือกกินจากต้นที่มีกล้วยมากกว่า แต่ถ้ากรณีที่มีต้นกล้วยมากกว่านี้จะทำยังไงดี?<br><center><img src="html/articles/img/1b85b184_2.png"  width="35%"><br style="line-height:170%">คำตอบของปัญหาย่อยสองข้อแรก ตัวเลขด้านขวาคือจำนวนกล้วยที่ก้านกล้วยเก็บได้<br></center>ในกรณีนี้เราจะมองว่าเราหาทางเลือกที่ดีที่สุดในการกินกล้วยจากต้นแรกถึงต้นที่เรายืนอยู่ (สังเกตว่าปัญหาย่อยของเรามีลักษณะเดียวกัน ปัญหาที่พูดถึงกรณีที่พิจารณาต้นแรกต้นเดียวก็เหมือนกับว่าเรายืนอยู่ที่ต้นแรก กรณีสองต้นแรกก็เหมือนว่าเรายืนอยู่ที่ต้นที่สอง ถ้าเรายืนอยู่ต้นสุดท้าย เราก็จะพิจารณาต้นกล้วยทุกต้น) สมมติว่าเราเลือกกระโดดเพื่อกินกล้วยจากต้นกล้วยต้นนี้ ผลรวมของกล้วยทั้งหมดที่เราจะได้ก็จะเท่ากับจำนวนกล้วยบนต้นนี้ บวกกับจำนวนที่เรากินได้ทั้งหมดตั้งแต่ต้นแรกจนถึงสองต้นก่อน (เรากินกล้วยจากต้นที่อยู่ก่อนหน้าไม่ได้ ไม่อย่างงั้นจะกระโดดกินที่ต้นนี้ไม่ได้) ส่วนถ้าเราเลือกไม่กระโดดที่ต้นนี้ เราก็จะได้กินกล้วยเท่ากับผลรวมจนถึงต้นก่อนหน้า ในกรณีนี้ก็จะมองง่ายขึ้นว่าทางเลือกที่ดีสุดก็คือทางเลือกจากสองทางนี้ที่ให้ผลมากกว่า<br><center><img src="html/articles/img/1b85b184_3.png"  width="80%"><br style="line-height:170%">คำตอบของปัญหาย่อยทั้งหมด สังเกตว่าคำตอบของทุกปัญหาย่อยจะสร้างมาจากคำตอบของปัญหาย่อยก่อนหน้าสองข้อ แล้วแต่ว่ากรณีไหนจะดีกว่า<br></center>ในการเขียนโปรแกรมที่ใช้ Dynamic Programming ถ้าจะใช้คำพูดมาอธิบายว่าโปรแกรมทำงานยังไง บางทีก็จะดูเยิ่นเย้อ เราจึงใช้สมการเป็นตัวอธิบายแทน ก่อนอื่นเราต้องนิยามปัญหาย่อยและตัวแปรไว้ก่อน เช่นในกรณีนี้จะนิยามว่า<br><center style="color: #000000;"><i>B</i>[<i>k</i>] คือจำนวนกล้วยบนต้นกล้วยต้นที่ <i>k</i><br><i>dp</i>[<i>k</i>] คือคำตอบของปัญหาย่อยข้อที่ <i>k</i> ซึ่งพิจารณาต้นกล้วยต้นที่ 1 - <i>k</i><br></center>จากนั้นเราจะเขียนเป็นสมการได้ว่า<br><center style="color: #000000;"><span><i>dp</i>[0] = <i>B</i>[0]</span><br><span><i>dp</i>[1] = <i>max</i>(<i>B</i>[0],<i>B</i>[1])</span><br>สำหรับ <i>k</i> &ge; 2: <span><i>dp</i>[<i>k</i>] = <i>max</i>(<i>dp</i>[<i>k</i> - 1], <i>dp</i>[<i>k</i> - 2] + <i>B</i>[<i>k</i>])</span><br></center>ในตอนแรกวิธีเขียนแบบนี้อาจจะดูเข้าใจยากกว่าเดิม แต่ถ้าเราเริ่มชินกับมันแล้ว มันจะเป็นอุปกรณ์ที่ทำให้เข้าใจได้ง่ายขึ้นและเร็วขึ้น โดยเฉพาะในกรณีที่อัลกอริทึมซับซ้อนกว่านี้<br>รวมๆ แล้วสิ่งที่เราต้องทำก็คือคำนวณผลลัพธ์ที่ดีที่สุด โดยสมมติว่ามีต้นกล้วยต้นแรกต้นเดียว จากนั้นก็ลองดูว่าถ้ามีต้นแรกและต้นที่สองแล้ว ผลลัพธ์จะเป็นยังไง แล้วก็หาคำตอบของสามต้นแรก สี่ต้นแรก ... ไปเรื่อยๆ โดยใช้คำตอบของต้นก่อนๆ ที่เคยคำนวณเก็บไว้มาแล้วมาใช้คิดต่อ จนครบถึงต้นสุดท้ายในแถว เราก็จะได้คำตอบที่เราอยากได้ตอนแรก<br>คอนเซ็ปต์หลักจริงๆ ของ Dynamic Programming ก็มีแค่นี้ แต่เทคนิคนี้ก็มีวิธีประยุกต์สำหรับโจทย์รูปแบบต่างๆ เยอะมาก และอาจจะใช้ความรู้ด้านอื่นๆ มาช่วยแก้ปัญหาด้วย ซึ่งเทคนิคเหล่านี้จะกล่าวถึงอีกในตอนต่อๆ ไป<br>
		</div>
	</body>
</html>