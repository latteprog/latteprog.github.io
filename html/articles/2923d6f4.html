<html>
	<head>
		<meta charset="UTF-8">
		
		<style>
			br
			{
				line-height: 340%;
			}

			div
			{
				line-height: 170%;
			}

			a
			{
				color: #C62818;
				text-decoration: none;
			}

			center
			{
				color: #C62818;
			}

			img
			{
				display: block;
			}
		</style>
	</head>

	<body>
		<div style="font-family: CSChatThai; font-size: 28px; line-height: 150%; color: #C62818; float: left;"><b>Faster Sorting Algorithm</b>&#09;<font face="CSChatThai" size="4" color="#999999">-&#09;19.05.2016</font></div>
			
		<div style="font-family: CSChatThai; font-size: 18px; line-height: 170%; text-align: justify; color: #000000; clear: both;">ตั้งแต่ยุค 1940 เราได้คิดค้นอัลกอริทึม <a href='https://en.wikipedia.org/wiki/Merge_sort' target='_blank'>Mergesort</a> ซึ่งสามารถแก้ปัญหาการเรียงลำดับได้รวดเร็ว (ใครไม่รู้จักก็อย่ากลัวไปนะครับ เอาเป็นว่าเราอยากให้คอมเรียงข้อมูลที่เรามีจากน้อยไปมาก) ต่อมาก็ได้คิดค้น <a href='https://en.wikipedia.org/wiki/Quicksort' target='_blank'>Quicksort</a> และ <a href='https://en.wikipedia.org/wiki/Heapsort' target='_blank'>Heapsort</a> ทั้งสามอัลกอริทึมนี้ใช้เวลา <i>O</i>(<i>n</i> log <i>n</i>) แต่จะมีอัลกอริทึมที่ทำได้เร็วกว่านี้รึเปล่า?<br>ในโพสนี้เราจะพูดถึงแต่อัลกอริทึมที่เรียงลำดับข้อมูลโดยใช้การเปรียบเทียบมากกว่าน้อยกว่า (Comparison sorting) หมายความว่าเราจะไม่พิจารณาอัลกอริทึมเช่น <a href='https://en.wikipedia.org/wiki/Radix_sort' target='_blank'>Radix sort</a>, <a href='https://en.wikipedia.org/wiki/Bucket_sort' target='_blank'>Bucket sort</a> ซึ่งใช้สมบัติอื่นๆ ของข้อมูลที่จะเรียงลำดับ หรือไม่ได้ใช้แค่การเปรียบเทียบมากกว่าน้อยกว่าในการประมวลผล<br><center><img src="html/articles/img/2923d6f4_3.png" width="70%"><br style="line-height:170%">การสลับที่ของข้อมูลเพื่อจัดเข้าลำดับที่เราต้องการ<br></center>ในอัลกอริทึมเหล่านี้ สิ่งที่เราทำคือเปรียบเทียบข้อมูล และย้ายหรือสลับที่ข้อมูลตามผลการเปรียบเทียบนั้น ถ้าเราจดลำดับการย้ายข้อมูลทั้งหมดไว้ตั้งแต่เริ่มจนจบ เราก็จะสามารถคำนวณย้อนไปได้ว่าตอนเริ่มต้นข้อมูลมีลำดับอย่างไร ฉะนั้นจริงๆ แล้วการเปรียบเทียบที่เราทำไปทั้งหมดก็เพื่อจะหาว่าลำดับข้อมูลที่เรามีอยู่เป็นอย่างไร<br>สิ่งที่เราต้องทำก็คือพยายามใช้การเปรียบเทียบน้อยครั้งที่สุด เพื่อที่จะหาลำดับข้อมูลที่เรามี หากรู้ลำดับข้อมูลแล้ว เราก็จะสลับข้อมูลให้เข้าที่ที่ถูกต้องได้ ถ้าสมมติเรามีข้อมูล <i>n</i> ตัว เราก็จะสามารถจัดข้อมูลเข้าที่ได้ด้วยการสลับไม่เกิน <i>n</i> ครั้ง ส่วนที่เหลืออยู่ก็คือส่วนการเปรียบเทียบหาลำดับ<br>ในตอนแรก ข้อมูลที่เรามีโอกาสอยู่ในลำดับ <i>n</i>! แบบ เมื่อเราเปรียบเทียบข้อมูลแต่ละครั้ง เราจะมีสิทธิ์ได้ผลลัพธ์สองแบบ ถ้าเราอยากใช้ผลลัพธ์ของการเปรียบเทียบมาหาลำดับข้อมูลนี้ ก็เหมือนกับมองว่าตอนแรกเรามีลำดับที่เป็นไปได้ทั้งหมด <i>n</i>! แบบ แล้วแต่ละครั้งที่เราได้ข้อมูลจากการเปรียบเทียบ เราก็จะตัดลำดับบางตัวไปได้ เพราะมันไม่ตรงกับการเปรียบเทียบ จนเราเหลือลำดับที่เป็นไปได้แบบเดียว ก็จะสรุปลำดับตอนแรกได้<br><center><img src="html/articles/img/2923d6f4_1.png" width="70%"><br style="line-height:170%">การจัดเรียงทั้งหมดที่เป็นไปได้ทั้งหมดของข้อมูล 4 ตัว<img src="html/articles/img/2923d6f4_2.png" width="70%"><br style="line-height:170%">หลังจากที่รู้ว่าข้อมูลตัวแรกมีค่าน้อยกว่าตัวที่สอง จะสามารถตัดการจัดเรียงที่เป็นสีเทาออกได้<img src="html/articles/img/2923d6f4_4.png" width="70%"><br style="line-height:170%">หลังจากการเปรียบเทียบ 5 ครั้ง เราสามารถตัดการเรียงลำดับจนเหลือแบบเดียวได้<br></center>จะเห็นว่าปัญหานี้สามารถแก้ได้ดีที่สุดด้วย Binary search ฉะนั้นจำนวนครั้งในการเปรียบเทียบที่เราต้องใช้ก็เท่ากับ log<sub>2</sub>(<i>n</i>!) ซึ่งสามารถใช้ <a href='https://en.wikipedia.org/wiki/Stirling%27s_approximation' target='_blank'>Stirling’s approximation</a> ประมาณได้ว่า<br>
		<table border="0" width="100%">
			<tr>
				<td width="50%" align="right">
					log<sub>2</sub>(<i>n</i>!) 
				</td>
				<td width="50%">
					= log(<i>n</i>!) / log(2)
				</td>
			</tr>
			<tr>
				<td width="50%"></td>
				<td width="50%">
					&#8776; (<i>n</i> log <i>n</i> - <i>n</i>) / log(2)
				</td>
			</tr>
		</table><br style="line-height: 170%;">
		 ซึ่งอยู่ใน O(<i>n</i> log <i>n</i>) เราสรุปได้ว่า O(<i>n</i> log <i>n</i>) เป็นเวลาที่ดีที่สุดในการเรียงลำดับข้อมูลด้วยการเปรียบเทียบแล้ว<br>จริงๆ แล้วเรายังสามารถสร้างอัลกอริทึมที่เร็วกว่า Quicksort ได้ และก็เคยมีคนทำมาแล้ว เช่น Introsort ซึ่งใช้หลายๆ อัลกอริทึมสำหรับแต่ละขนาดข้อมูล แต่อัลกอริทึมเหล่านี้ก็ยังใช้เวลา O(<i>n</i> log <i>n</i>) และเราก็ได้พิสูจน์แล้วว่าจะไม่มีอัลกอริทึมที่ใช้เวลาน้อยกว่านี้<br>
		</div>
	</body>
</html>