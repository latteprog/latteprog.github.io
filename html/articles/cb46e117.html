<html>
	<head>
		<meta charset="UTF-8">

		<style>
			br
			{
				line-height: 340%;
			}

			div
			{
				line-height: 170%;
			}

			a
			{
				color: #C62818;
				text-decoration: none;
			}

			span
			{
				white-space: pre;
			}
		</style>

		<script type="text/javascript" src="/js/jquery.min.js"></script>
	</head>

	<body>
		<div style="font-family: CSChatThai; font-size: 28px; line-height: 150%; color: #C62818; float: left;"><b>Dynamic Programming - Knapsack</b>&#09;<font face="CSChatThai" size="4" color="#999999">-&#09;09.07.2016</font></div>
		<div style="font-family: CSChatThai; font-size: 18px; text-align: justify; color: #000000; clear: both;">
		ในตอนนี้เราจะพูดถึงปัญหาคลาสสิกปัญหาหนึ่ง คือปัญหา Knapsack ซึ่งเกี่ยวกับการเก็บของใส่กระเป๋าเพื่อให้ได้มูลค่ามากที่สุด กล่าวคือ เราจะมีของอยู่หลายๆ  แบบ ซึ่งแต่ละแบบจะมีมูลค่าไม่เท่ากันและมีน้ำหนักไม่เท่ากัน ทีนี้เราต้องการเก็บของใส่กระเป๋าเพื่อให้ได้มูลค่ามากที่สุด แต่เนื่องจากกระเป๋าใบนี้ใส่ของได้จำกัด เราจึงต้องหาวิธีเก็บที่จะเก็บของดีๆ<br>จริงๆ แล้วปัญหานี้มีหลาย Variant แต่เราจะพูดถึงแค่ Variant เดียว คือปัญหา 0/1 Knapsack ซึ่งมีกฏเพิ่มเติมว่าของแต่ละแบบจะมีอยู่แค่ชิ้นเดียว (ไม่สามารถหยิบของแบบเดิมซ้ำสองครั้งได้) และของแต่ละชิ้นที่หยิบจะต้องหยิบเต็มชิ้น (ไม่สามารถแบ่งของเป็นครึ่งชิ้นแล้วใส่กระเป๋าแค่ครึ่งเดียว) สองกฎที่เพิ่มมานี้จึงเป็นที่มาของชื่อ 0/1<br>ตัวอย่างเช่น ถ้าสมมติมีของสามชิ้น ดงันี้
		<ul>
			<li>ของน้ำหนัก 2 หน่วย มีค่า 3 หน่วย</li>
			<li>ของน้ำหนัก 3 หน่วย มีค่า 7 หน่วย</li>
			<li>ของน้ำหนัก 5 หน่วย มีค่า 9 หน่วย</li>
		</ul>และกระเป๋ารับน้ำหนักได้ 5 หน่วย การจัดของใส่กระเป๋าให้ได้มูลค่ารวมมากที่สุดคือเก็บของชิ้นที่ 1 และ 2 ได้มูลค่า 10 หน่วย<br>ก่อนจะพูดถึงวิธีแก้ เราจะกำหนดสัญลักษณ์ให้กับตัวแปรต่างๆ ในปัญหาก่อน
		<ul>
			<li><i>w</i>[<i>i</i>] แทนน้ำหนักของของชิ้นที่ <i>i</i></li>
			<li><i>c</i>[<i>i</i>] แทนมูลค่าของของชิ้นที่ <i>i</i></li>
		</ul>
		ขั้นแรกที่เราจะใช้ Dynamic Programming มาแก้ปัญหา คือเราควรจะมองให้ออกก่อนว่าจะแบ่ปัญหาย่อยยังไงเพื่อให้เราสามารถแก้ปัญหาง่ายขึ้น ค่าหนึ่งที่ดูน่าสนใจตั้งแต่แรกคือลองเพิ่มของทีละชิ้น คือลองคำนวณก่อนว่าถ้าพิจารณาแค่ของแบบแรกแล้วจะใส่ได้แบบไหนบ้าง แล้วลองพิจารณาของสองแบบแล้วจะเป็นยังไง ทำต่อไปเรื่อยๆ จนได้ของครบ แต่เนื่องจากท้ายที่สุดแล้วเราจะต้องคำนวณทางเลือกทุกแบบ ซึ่งมีทั้งหมด 2<sup><i>n</i></sup> แบบ ซึ่งเป็นฟังก์ชั่นที่เติบโตเร็วมาก เราจึงอยากได้ทางเลือกอื่น<br>เราจะใช้ค่าอีกค่าเป็นตัวช่วยแบ่งปัญหาย่อย ค่าที่สองนี้ก็คือน้ำหนักของของที่อยู่ในกระเป๋า เมื่อใช่ค่านี้ร่วมกับจำนวนของที่พิจารณาแล้ว จะได้ว่าแต่ละปัญหาย่อยคือ "ถ้าใช้ของตั้งแต่ชิ้นแรกถึงชิ้นที่พิจารณาอยู่ โดยกำหนดให้น้ำหนักของในกระเป๋าไม่เกินน้ำหนักที่พิจารณาอยู่ จะเก็บของได้มูลค่ามากที่สุดเท่าไหร่" ซึ่งเราจะเห็นว่าการแบ่งปัญหาย่อยแบบนี้ทำให้การคำนวณง่ายขึ้นมาก<br>ถ้าเราพิจารณาปัญหาย่อยหนึ่ง โดยเราคำนวณมูลค่าที่มากที่สุดโดยใช้ของชิ้นที่ 1 ถึง <i>k</i> และให้น้ำหนักไม่เกิน <i>W</i> จะเห็นว่าทางเลือกที่เรามีก็คือเลือกใส่ของชิ้นที่ <i>k</i> ในกระเป๋า หรือไม่ก็ไม่ใส่ แต่ละทางเลือกจะเขียนสมการได้ดังนี้
		<ul>
			<li>ไม่ใส่ของเพิ่ม โดยไม่พิจารณาถึงของชิ้นที่ <i>k</i>: <span><i>dp</i>[<i>k</i> - 1][<i>W</i>]</span></li>
			<li>ใส่ของเพิ่ม โดยตัดของชิ้นที่ <i>k</i> และตัดน้ำหนักของของชิ้นที่ <i>k</i> ออก: <span><i>dp</i>[<i>k</i> - 1][<i>W</i> - <i>w</i>[<i>k</i>]] + <i>c</i>[<i>k</i>]</span></li>
			<li>ไม่ใส่ของเพิ่ม โดยไม่พิจารณาการจำกัดน้ำหนักที่เพิ่มมา: <span><i>dp</i>[<i>k</i>][<i>W</i> - 1]</span></li>
		</ul>
		เมื่อนำทางเลือกสามทางนี้มารวมกันแล้ว จะได้สมการว่า<br><center>สำหรับ <i>k</i> &lt; 1 หรือ <i>W</i> &lt; 1: <span><i>dp</i>[k][W] = 0</span><br>สำหรับ <i>k</i> &ge; 1 และ <i>W</i> &ge; 1: <span><i>dp</i>[<i>k</i>][<i>W</i>] = <i>max</i>(<i>dp</i>[<i>k</i> - 1][<i>W</i>], <i>dp</i>[<i>k</i>][<i>W</i> - 1], <br style="line-height: 170%;"><i>dp</i>[<i>k</i> - 1][<i>W</i> - <i>w</i>[<i>k</i>]] + <i>c</i>[<i>k</i>])</span></center><br>อัลกอริทึมนี้ใช้ เวลา <i>O</i>(<i>nW</i>) ในการทำงาน เมื่อ <i>n</i> แทนจำนวนชนิดของของและ <i>W</i> แทนน้ำหนักที่กระเป๋าจุได้<br>
		</div>
	</body>
</html>